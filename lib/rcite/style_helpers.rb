require 'rcite/element'

module RCite
  class Style

    # @return [Hash<Symbol, Option>] This style's global {Option}s. Keys are
    #   option names ({Option#name}), values are the {Option} objects that
    #   describe the behaviour of various helper methods. For a list of all
    #   options see {Style::OPTIONS}.
    attr_accessor :opts

    # Returns the value of a BibTeX field for the current {#text}.
    #
    # @param [#to_sym] method Any field that can be specified in a
    #   BibTeX entry, like `title`, `year`, `shorttitle`, `url` etc. May not
    #   begin with an underscore.
    #
    # @return [String,nil] The field's value if it is set in the BibTeX entry
    #   {#text}, otherwise `nil`.
    #
    # @raise NoMethodError if {#text} `== nil`.
    def method_missing(method, *args)
      raise NoMethodError,
        "Can't look up BibTeX fields: Style#text is `nil`" unless @text
      @text[method.to_sym]
    end

    # Adds each style option in {OPTIONS} to {#opts}.
    #
    # @api user
    def initialize
      @opts = {}
      OPTIONS.each { |o| @opts.merge!(o.name => o.dup) }
    end

    # Adds the specified `elements` to the variable `@elements`. Each
    # element can be either a `String` or an `Element`. `String`s are
    # converted to `Elements` of type `:con` before appending. `nil` arguments
    # and empty strings are dropped.
    #
    # @param [Element,String] elements Any number of elements or strings
    #   that should be appended to @elements.
    #
    # @api user
    def add(*elements)
      elements.map! do |e|
        if e.is_a? RCite::Element
          e
        elsif e && e.to_s == ''
          nil
        elsif e
          RCite::Element.new(:con, e)
        end
      end

      @elements.concat elements.compact
    end

    # Defines a separator element. This method is a very simple helper method
    # for style generation which can be used to indicate that `separator` is
    # a separator, not bibliographic data. This method should be used in
    # conjunction with {#add}, as shown in the example.
    #
    # @example Using `sep` with `add`
    #   add authors
    #   add sep ': '
    #   add title
    #
    # @param [String] separator Some string that should be used as a separator.
    #
    # @return [Element] An `Element` of type `:sep` with `separator` as the
    #   element's `content`.
    #
    # @api user
    def sep(separator)
      RCite::Element.new(:sep, separator)
    end

    # Returns a list of all authors of the given text if any are defined.
    #
    # @param [Hash] options Controls the style of the list generated by this
    #   method.
    #   
    # @option options [:first_last, :last_first] :ordering Controls
    #   the order in which family and given names are printed. If `:first_last`
    #   is given, Mr Theodor zu Guttenberg is printed as
    #   "Theodor zu Guttenberg". For `:last_first` it's
    #   "zu Guttenberg, Theodor".
    # @option options [String] :delim The list delimiter.
    # @option options [Integer] :et_al The maximum number of persons that are
    #   listed. If there are more person, `:et_al_string` is added to the end
    #   of the list.
    # @option options [String] :et_al_string The term that is appended when
    #   more than `:et_al` persons are given.
    # 
    # @return [String, nil] The list of authors, or `nil` if the bibliographic
    #   data for this text defines none.
    #
    # @api user
    def authors()
      authors_or_editors(@text[:author].to_names) if @text[:author]
    end

    alias author authors

    # Returns a list of all editors of the given text if any are defined.
    #
    # @param (see #authors)
    # @option (see #authors)
    # @return [String,nil] The list of editors, or `nil` if the bibliographic
    #   data for this text defines none.
    #
    # @api user
    def editors(options = {})
      authors_or_editors(@text[:editor].to_names) if @text[:editor]
    end

    alias editor editors

    #=========================== BEGIN PRIVATE ================================

    private

    def authors_or_editors(list)
      return if list == nil

      list = list.map do |person|
        string = ''
        case _ordering
          when :last_first
            string << list([person.prefix, person.last], " ")
            string << ", #{person.first}" if person.first
          when :first_last
            string << list([person.first, person.prefix, \
                            person.last], " ")
        end
        string
      end

      print_et_al = false
      max_num_of_persons = _et_al
      if max_num_of_persons && list.size > max_num_of_persons
        list = list[0..(max_num_of_persons-1)]
        print_et_al = true
      end

      string = list(list, _delim)

      string << " " + _et_al_string if print_et_al
      return string
    end

    def list(list, delim)
      list.compact.join(delim)
    end

  end
end
